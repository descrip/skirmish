-- Create all of the tables.
CREATE TABLE languages (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	version VARCHAR(255) NOT NULL,
	extension VARCHAR(255) NOT NULL,
	compile_command VARCHAR(255),
	execute_command VARCHAR(255) NOT NULL
);

CREATE TABLE verdicts (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) NOT NULL,
	code VARCHAR(255) UNIQUE NOT NULL,
	is_accepted BOOLEAN NOT NULL DEFAULT 0,
    priority INTEGER UNIQUE NOT NULL
);

CREATE TABLE contests (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	slug VARCHAR(255) UNIQUE NOT NULL,
	body TEXT NOT NULL,
	start_time TIMESTAMP NOT NULL DEFAULT '1970-01-01 00:00:01',
	end_time TIMESTAMP NOT NULL DEFAULT '1970-01-01 00:00:01'
);

CREATE TABLE users (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(255) UNIQUE NOT NULL,
	email VARCHAR(255) UNIQUE NOT NULL,
	password VARCHAR(255) NOT NULL,
	points INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE problems (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	slug VARCHAR(255) UNIQUE NOT NULL,
	body TEXT NOT NULL,
	memory_limit INTEGER NOT NULL,
	time_limit INTEGER NOT NULL,
	points INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	contest_id INTEGER,
	FOREIGN KEY(contest_id) REFERENCES contests(id) ON DELETE CASCADE
);

CREATE TABLE subtasks (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	problem_id INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(problem_id) REFERENCES problems(id) ON DELETE CASCADE
);

CREATE TABLE testcases (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	input TEXT NOT NULL,
	output TEXT NOT NULL,	-- TODO: Support for program-based checking?
	subtask_id INTEGER NOT NULL,
	marks INTEGER NOT NULL,
	FOREIGN KEY(subtask_id) REFERENCES subtasks(id) ON DELETE CASCADE
);

CREATE TABLE submissions (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	problem_id INTEGER NOT NULL,
	user_id INTEGER NOT NULL,
	verdict_id INTEGER NOT NULL DEFAULT 1,
	language_id INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	points INTEGER NOT NULL DEFAULT 0,
	subtask_results_with_default_verdict_count INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(problem_id) REFERENCES problems(id),
	FOREIGN KEY(user_id) REFERENCES users(id),
	FOREIGN KEY(verdict_id) REFERENCES verdicts(id),
	FOREIGN KEY(language_id) REFERENCES languages(id)
);

CREATE TABLE subtask_results (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	submission_id INTEGER NOT NULL,
	subtask_id INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	verdict_id INTEGER NOT NULL DEFAULT 1,
	testcase_results_with_default_verdict_count INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(verdict_id) REFERENCES verdicts(id),
	FOREIGN KEY(submission_id) REFERENCES submissions(id) ON DELETE CASCADE,
	FOREIGN KEY(subtask_id) REFERENCES subtasks(id)
);

CREATE TABLE testcase_results (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	subtask_result_id INTEGER NOT NULL,
	testcase_id INTEGER NOT NULL,
	verdict_id INTEGER NOT NULL DEFAULT 1,
	FOREIGN KEY(subtask_result_id) REFERENCES subtask_results(id) ON DELETE CASCADE,
	FOREIGN KEY(testcase_id) REFERENCES testcases(id),
	FOREIGN KEY(verdict_id) REFERENCES verdicts(id)
);

CREATE TABLE users_solved_problems_pivot (
	user_id INTEGER NOT NULL,
	FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE,
	problem_id INTEGER NOT NULL,
	FOREIGN KEY(problem_id) REFERENCES problems(id) ON DELETE CASCADE,
	submission_id INTEGER NOT NULL,
	FOREIGN KEY(submission_id) REFERENCES submissions(id) ON DELETE CASCADE,
	PRIMARY KEY(user_id, problem_id)
);

CREATE TABLE users_entered_contests_pivot (
	user_id INTEGER NOT NULL,
	FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE,
	contest_id INTEGER NOT NULL,
	FOREIGN KEY(contest_id) REFERENCES contests(id) ON DELETE CASCADE,
	PRIMARY KEY(user_id, contest_id)
);

CREATE TABLE test_table (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	wow INTEGER
);

-- DELIMITER //

-- Create triggers on testcases to update subtasks on any C(R)UD.
CREATE TRIGGER update_subtasks_on_insert BEFORE INSERT ON testcases FOR EACH ROW
UPDATE subtasks SET marks = marks + NEW.marks WHERE id = NEW.subtask_id;

CREATE TRIGGER update_subtasks_on_update BEFORE UPDATE ON testcases FOR EACH ROW
BEGIN
	UPDATE subtasks SET marks = marks - OLD.marks WHERE id = OLD.subtask_id;
	UPDATE subtasks SET marks = marks + NEW.marks WHERE id = NEW.subtask_id;
END;

CREATE TRIGGER update_subtasks_on_delete BEFORE DELETE ON testcases FOR EACH ROW
UPDATE subtasks SET marks = marks - OLD.marks WHERE id = OLD.subtask_id;

-- Create triggers on subtasks to relay that information to problems on C(R)UD.
CREATE TRIGGER update_problems_on_insert BEFORE INSERT ON subtasks FOR EACH ROW
UPDATE problems SET marks = marks + NEW.marks WHERE id = NEW.problem_id;

CREATE TRIGGER update_problems_on_update BEFORE UPDATE ON subtasks FOR EACH ROW
BEGIN
	UPDATE problems SET marks = marks - OLD.marks WHERE id = OLD.problem_id;
	UPDATE problems SET marks = marks + NEW.marks WHERE id = NEW.problem_id;
END;

CREATE TRIGGER update_problems_on_delete BEFORE DELETE ON subtasks FOR EACH ROW
UPDATE problems SET marks = marks - OLD.marks WHERE id = OLD.problem_id;

-- Create triggers on testcase_results to update on subtask_results on any C(R)UD if an accepted verdict was assigned.
CREATE TRIGGER update_subtask_results_on_insert BEFORE INSERT ON testcase_results FOR EACH ROW
BEGIN
	SELECT is_accepted INTO @is_accepted FROM verdicts WHERE id = NEW.verdict_id;
	SELECT marks INTO @marks FROM testcases WHERE id = NEW.testcase_id;

	UPDATE subtask_results SET
		marks = CASE
			WHEN @is_accepted THEN marks + @marks
			ELSE marks
		END,
		testcase_results_with_default_verdict_count = CASE
			WHEN NEW.verdict_id = 1 THEN testcase_results_with_default_verdict_count + 1
			ELSE testcase_results_with_default_verdict_count  
		END,
		verdict_id = CASE
			WHEN NEW.verdict_id > verdict_id THEN NEW.verdict_id
			ELSE verdict_id
		END
	WHERE id = NEW.subtask_result_id;
END;

CREATE TRIGGER update_subtask_results_on_update BEFORE UPDATE ON testcase_results FOR EACH ROW
BEGIN
	INSERT INTO test_table(wow) VALUES(3);

	SELECT is_accepted INTO @old_is_accepted FROM verdicts WHERE id = OLD.verdict_id;
	SELECT marks INTO @old_marks FROM testcases WHERE id = OLD.testcase_id;
	SELECT is_accepted INTO @new_is_accepted FROM verdicts WHERE id = NEW.verdict_id;
	SELECT marks INTO @new_marks FROM testcases WHERE id = NEW.testcase_id;

	INSERT INTO test_table(wow) VALUES(3);

	UPDATE subtask_results SET
		marks = CASE
			WHEN @old_is_accepted THEN marks - @marks
			ELSE marks
		END,
		testcase_results_with_default_verdict_count = CASE
			WHEN OLD.verdict_id = 1 THEN testcase_results_with_default_verdict_count - 1
			ELSE testcase_results_with_default_verdict_count 
		END
	WHERE id = OLD.subtask_result_id;

	UPDATE subtask_results SET
		marks = CASE
			WHEN @new_is_accepted THEN marks + @marks
			ELSE marks
		END,
		testcase_results_with_default_verdict_count = CASE
			WHEN NEW.verdict_id = 1 THEN testcase_results_with_default_verdict_count + 1
			ELSE testcase_results_with_default_verdict_count  
		END,
		verdict_id = CASE
			WHEN NEW.verdict_id > verdict_id THEN NEW.verdict_id
			ELSE verdict_id
		END
	WHERE id = NEW.subtask_result_id;
END;

-- Create triggers on subtask_results to relay information to submissions on any C(R)UD.
CREATE TRIGGER update_submissions_on_insert BEFORE INSERT ON subtask_results FOR EACH ROW
BEGIN
	UPDATE submissions SET
		marks = marks + NEW.marks,
		subtask_results_with_default_verdict_count = CASE
			WHEN NEW.verdict_id = 1 THEN subtask_results_with_default_verdict_count + 1
			ELSE subtask_results_with_default_verdict_count
		END,
		verdict_id = CASE
			WHEN NEW.verdict_id > verdict_id THEN NEW.verdict_id
			ELSE verdict_id
		END
	WHERE id = NEW.submission_id;
END;

CREATE TRIGGER update_submissions_on_update BEFORE UPDATE ON subtask_results FOR EACH ROW
BEGIN
	UPDATE submissions SET
		marks = marks - OLD.marks,
		subtask_results_with_default_verdict_count = CASE
			WHEN OLD.verdict_id = 1 THEN subtask_results_with_default_verdict_count - 1
			ELSE subtask_results_with_default_verdict_count
		END
	WHERE id = OLD.submission_id;

	UPDATE submissions SET
		marks = marks + NEW.marks,
		subtask_results_with_default_verdict_count = CASE
			WHEN NEW.verdict_id = 1 THEN subtask_results_with_default_verdict_count + 1
			ELSE subtask_results_with_default_verdict_count
		END,
		verdict_id = CASE
			WHEN NEW.verdict_id > verdict_id THEN NEW.verdict_id
			ELSE verdict_id
		END
	WHERE id = NEW.submission_id;
END;

-- Create a trigger such that when all subtasks have reported a result, calculate the points awarded.
CREATE TRIGGER update_submissions_after_testing_finish BEFORE UPDATE ON submissions FOR EACH ROW
BEGIN
	IF NEW.subtask_results_with_default_verdict_count = 0 THEN
		SELECT marks, points INTO @total_marks, @total_points FROM problems WHERE id = NEW.problem_id;
		SET NEW.points = ROUND(NEW.marks / @total_marks * @total_points, 2);

		-- Update the best submission in the user_solved_problems_pivot we have if this one is better.
		IF EXISTS(SELECT 1 FROM users_solved_problems_pivot WHERE user_id = NEW.user_id AND problem_id = NEW.problem_id) THEN
			SELECT submission_id INTO @best_submission_id FROM users_solved_problems_pivot 
				WHERE problem_id = NEW.problem_id
				AND user_id = NEW.user_id;
			SELECT points INTO @best_points FROM submissions
				WHERE id = @best_submission_id;

			IF NEW.points > @best_points THEN
				UPDATE users_solved_problems_pivot SET submission_id = NEW.id
					WHERE problem_id = NEW.problem_id
					AND user_id = NEW.user_id;
			END IF;
		ELSE
			INSERT INTO users_solved_problems_pivot(user_id, problem_id, submission_id)
			VALUES(NEW.user_id, NEW.problem_id, NEW.id);
		END IF;

	END IF;
END;

-- Create triggers to relay point updates from the pivot table to users.
CREATE TRIGGER update_users_on_insert BEFORE INSERT ON users_solved_problems_pivot FOR EACH ROW
BEGIN
	SELECT points INTO @points FROM submissions WHERE id = NEW.submission_id;
	UPDATE users SET points = points + @points WHERE id = NEW.user_id;
END;

CREATE TRIGGER update_users_on_update BEFORE UPDATE ON users_solved_problems_pivot FOR EACH ROW
BEGIN
	SELECT points INTO @old_points FROM submissions WHERE id = OLD.submission_id;
	UPDATE users SET points = points - @old_points WHERE id = OLD.user_id;
	SELECT points INTO @new_points FROM submissions WHERE id = NEW.submission_id;
	UPDATE users SET points = points + @new_points WHERE id = NEW.user_id;
END;

-- DELIMITER ;
