-- Create all of the tables.
CREATE TABLE languages (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	version VARCHAR(255) NOT NULL,
	extension VARCHAR(255) NOT NULL,
	compile_command VARCHAR(255),
	execute_command VARCHAR(255) NOT NULL
);

CREATE TABLE verdicts (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) NOT NULL,
	code VARCHAR(255) UNIQUE NOT NULL,
	is_accepted BOOLEAN NOT NULL DEFAULT 0
);

CREATE TABLE contests (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	slug VARCHAR(255) UNIQUE NOT NULL,
	start_time TIMESTAMP NOT NULL DEFAULT '1970-01-01 00:00:01',
	end_time TIMESTAMP NOT NULL DEFAULT '1970-01-01 00:00:01'
);

CREATE TABLE users (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(255) UNIQUE NOT NULL,
	email VARCHAR(255) UNIQUE NOT NULL,
	password VARCHAR(255) NOT NULL
);

CREATE TABLE problems (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(255) UNIQUE NOT NULL,
	slug VARCHAR(255) UNIQUE NOT NULL,
	body TEXT NOT NULL,
	memory_limit INTEGER NOT NULL,
	time_limit INTEGER NOT NULL,
	points INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	contest_id INTEGER,
	FOREIGN KEY(contest_id) REFERENCES contests(id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE subtasks (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	problem_id INTEGER NOT NULL,
	marks INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(problem_id) REFERENCES problems(id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE testcases (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	input TEXT NOT NULL,
	output TEXT NOT NULL,	-- TODO: Support for program-based checking?
	subtask_id INTEGER NOT NULL,
	marks INTEGER NOT NULL,
	FOREIGN KEY(subtask_id) REFERENCES subtasks(id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE submissions (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	problem_id INTEGER NOT NULL,
	user_id INTEGER NOT NULL,
	verdict_id INTEGER NOT NULL DEFAULT 1,
	language_id INTEGER NOT NULL,
	marks_awarded INTEGER NOT NULL DEFAULT 0,
	points_awarded INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(problem_id) REFERENCES problems(id) ON UPDATE CASCADE,
	FOREIGN KEY(user_id) REFERENCES users(id) ON UPDATE CASCADE,
	FOREIGN KEY(verdict_id) REFERENCES verdicts(id) ON UPDATE CASCADE,
	FOREIGN KEY(language_id) REFERENCES languages(id) ON UPDATE CASCADE
);

CREATE TABLE subtask_results (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	submission_id INTEGER NOT NULL,
	subtask_id INTEGER NOT NULL,
	marks_awarded INTEGER NOT NULL DEFAULT 0,
	FOREIGN KEY(submission_id) REFERENCES submissions(id) ON UPDATE CASCADE ON DELETE CASCADE,
	FOREIGN KEY(subtask_id) REFERENCES subtasks(id) ON UPDATE CASCADE
);

CREATE TABLE testcase_results (
	id INTEGER PRIMARY KEY AUTO_INCREMENT,
	subtask_result_id INTEGER NOT NULL,
	testcase_id INTEGER NOT NULL,
	verdict_id INTEGER NOT NULL,
	FOREIGN KEY(subtask_result_id) REFERENCES subtask_results(id) ON UPDATE CASCADE ON DELETE CASCADE,
	FOREIGN KEY(testcase_id) REFERENCES testcases(id) ON UPDATE CASCADE,
	FOREIGN KEY(verdict_id) REFERENCES verdicts(id) ON UPDATE CASCADE
);

CREATE TABLE users_problems_pivot (
	user_id INTEGER NOT NULL,
	FOREIGN KEY(user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,
	problem_id INTEGER NOT NULL,
	FOREIGN KEY(problem_id) REFERENCES problems(id) ON UPDATE CASCADE ON DELETE CASCADE,
	submission_id INTEGER NOT NULL,
	FOREIGN KEY(submission_id) REFERENCES submissions(id) ON UPDATE CASCADE ON DELETE CASCADE,
	PRIMARY KEY(user_id, problem_id)
);

CREATE TABLE users_contests_pivot (
	user_id INTEGER NOT NULL,
	FOREIGN KEY(user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE,
	contest_id INTEGER NOT NULL,
	FOREIGN KEY(contest_id) REFERENCES contests(id) ON UPDATE CASCADE ON DELETE CASCADE,
	PRIMARY KEY(user_id, contest_id)
);

CREATE PROCEDURE update_marks_for_subtask(subtask_id INTEGER) RETURNS INTEGER
BEGIN
	SELECT COUNT(marks) INTO @marks FROM testcases WHERE subtask_id = subtask_id;
	UPDATE subtasks SET marks = @marks WHERE id = subtask_id;
	RETURN @marks;
END

CREATE PROCEDURE update_marks_for_problem(problem_id INTEGER)
BEGIN
	DECLARE DONE BOOLEAN DEFAULT FALSE;
END

-- Triggers for updating marks on problems, subtasks based on CRUD on testcases
-- TODO: Call a function instead.
--CREATE TRIGGER update_marks_on_insert BEFORE INSERT ON testcases
--BEGIN
--	SELECT problem_id INTO @problem_id FROM subtasks WHERE id = NEW.subtask_id;
--	UPDATE subtasks SET marks = marks + NEW.marks WHERE id = NEW.subtask_id;
--	UPDATE problems SET marks = marks + NEW.marks WHERE id = NEW.problem_id;
--END
--
--CREATE TRIGGER update_marks_on_delete BEFORE DELETE ON testcases
--BEGIN
--	SELECT problem_id INTO @problem_id FROM subtasks WHERE id = OLD.subtask_id;
--	UPDATE subtasks SET marks = marks - OLD.marks WHERE id = OLD.subtask_id;
--	UPDATE problems SET marks = marks - OLD.marks WHERE id = OLD.problem_id;
--END
--
--CREATE TRIGGER update_marks_on_update BEFORE UPDATE ON testcases
--BEGIN
--	SELECT problem_id INTO @problem_id FROM subtasks WHERE id = NEW.subtask_id;
--	UPDATE subtasks SET marks = marks - OLD.marks WHERE id = OLD.subtask_id;
--	UPDATE problems SET marks = marks - OLD.marks WHERE id = OLD.problem_id;
--	UPDATE subtasks SET marks = marks + NEW.marks WHERE id = NEW.subtask_id;
--	UPDATE problems SET marks = marks + NEW.marks WHERE id = NEW.problem_id;
--END
--
--
--CREATE TRIGGER update_marks_and_points_awarded_on_insert BEFORE INSERT ON testcase_results
--BEGIN
--	SELECT is_accepted INTO @is_accepted FROM verdicts WHERE id = NEW.verdict_id;
--	IF (@is_accepted) THEN
--		SELECT marks INTO @marks FROM testcases WHERE id = NEW.testcase_id;
--		UPDATE subtask_results SET marks_awarded = marks_awarded + @marks WHERE id = NEW.subtask_result_id;
--		SELECT submission_id INTO @submission_id FROM subtask_results WHERE id = NEW.subtask_result_id;
--		UPDATE submissions SET marks_awarded = marks_awarded + @marks WHERE id = @submission_id;
--	END
--END
--
--CREATE TRIGGER update_marks_and_points_awarded_on_delete BEFORE DELETE ON testcase_results
--BEGIN
--	SELECT is_accepted INTO @is_accepted FROM verdicts WHERE id = NEW.verdict_id;
--	IF (@is_accepted) THEN
--		SELECT marks INTO @marks FROM testcases WHERE id = OLD.testcase_id;
--		UPDATE subtask_results SET marks_awarded = marks_awarded - @marks WHERE id = OLD.subtask_result_id;
--		SELECT submission_id INTO @submission_id FROM subtask_results WHERE id = OLD.subtask_result_id;
--		UPDATE submissions SET marks_awarded = marks_awarded - @marks WHERE id = @submission_id;
--	END
--END
